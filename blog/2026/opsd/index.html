<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Self-Distilled Reasoner: On-Policy Self-Distillation | Siyan Zhao</title> <meta name="author" content="Siyan Zhao"> <meta name="description" content="As models continue to scale, the self-teaching capability may become increasingly valuable—enabling more efficient training. Much like a student reviewing solutions, rationalizing them, and correcting their prior mistakes, an LLM can be conditioned on the correct solution/reasoning trace and supervise its weaker self (the version without access to the solution) by matching the privileged-info induced distribution from itself."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%A4%96&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://siyan-zhao.github.io/blog/2026/opsd/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> <style type="text/css">.equation-block{background:#f8f9fa;border-left:3px solid #4caf50;padding:15px;margin:20px 0}.highlight-box{background:#e3f2fd;border-radius:8px;padding:20px;margin:20px 0}</style> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "Self-Distilled Reasoner: On-Policy Self-Distillation",
      "description": "As models continue to scale, the self-teaching capability may become increasingly valuable—enabling more efficient training. Much like a student reviewing solutions, rationalizing them, and correcting their prior mistakes, an LLM can be conditioned on the correct solution/reasoning trace and supervise its weaker self (the version without access to the solution) by matching the privileged-info induced distribution from itself.",
      "published": "January 21, 2026",
      "authors": [
        {
          "author": "Siyan Zhao (Project Lead)",
          "authorURL": "#",
          "affiliations": [
            {
              "name": "UCLA",
              "url": ""
            }
          ]
        },
        {
          "author": "et al.",
          "authorURL": "",
          "affiliations": [
            {
              "name": "UCLA, HKU, Meta",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Siyan Zhao</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications and Preprints</a> </li> <li class="nav-item "> <a class="nav-link" href="/talks/">Invited Talks</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">Experience</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Self-Distilled Reasoner: On-Policy Self-Distillation</h1> <p>As models continue to scale, the self-teaching capability may become increasingly valuable—enabling more efficient training. Much like a student reviewing solutions, rationalizing them, and correcting their prior mistakes, an LLM can be conditioned on the correct solution/reasoning trace and supervise its weaker self (the version without access to the solution) by matching the privileged-info induced distribution from itself.</p> </d-title><d-byline></d-byline><d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#the-challenge-of-current-training-paradigms">The Challenge of Current Training Paradigms</a></div> <div><a href="#core-insight">Core Insight</a></div> <div><a href="#methodology">Methodology</a></div> <div><a href="#experimental-results">Experimental Results</a></div> <div><a href="#ablation-studies">Ablation Studies</a></div> <div><a href="#limitations-and-future-directions">Limitations and Future Directions</a></div> </nav> </d-contents> <h2 id="the-challenge-of-current-training-paradigms">The Challenge of Current Training Paradigms</h2> <p>Large language models have shown impressive abilities in complex reasoning tasks, but finding the best ways to train them is still an open problem. Current approaches come with their own trade-offs and limitations:</p> <p><strong>Supervised Fine-Tuning (SFT)</strong> employs fixed expert demonstrations for training but encounters exposure bias—the model’s training distribution diverges from its test-time behavior, as it never observes its own errors during training. This distributional mismatch can lead to compounding errors during autoregressive generation.</p> <p><strong>Reinforcement Learning</strong> methods, such as Group Relative Policy Optimization (GRPO), address this limitation through on-policy training on the model’s own outputs. However, these approaches suffer from computational inefficiency, requiring multiple rollouts per problem instance (typically 8 or more), and provide only sparse, sequence-level feedback signals. The binary nature of outcome verification—correct or incorrect—offers no intermediate guidance regarding which specific reasoning steps are suboptimal.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/opsd/opsd_tab1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 1: Comparison of training methods for reasoning tasks. On-Policy Self-Distillation (OPSD) combines the advantages of on-policy training with dense feedback without requiring an external teacher model. </div> <h2 id="core-insight">Core Insight</h2> <p>Our approach draws inspiration from human pedagogical practices. When students solve problems incorrectly, effective learning occurs not through binary feedback alone, but through examination of correct solutions, understanding of reasoning steps, and identification of divergence points in their own reasoning process.</p> <p>We pose the following research question: <strong>Can a sufficiently capable language model leverage its own rationalization abilities for self-improvement?</strong> Specifically, can a model, when provided access to correct solutions, rationalize the reasoning steps and provide supervision to its weaker counterpart (the version without privileged information)?</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/opsd/opsd_main.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 2: Overview of On-Policy Self-Distillation framework. A single language model instantiates both student and teacher policies through differential conditioning contexts. </div> <p>We show that the answer is yes through <strong>On-Policy Self-Distillation (OPSD)</strong>, where a single model plays two roles:</p> <ul> <li> <strong>Student policy</strong> \(p_S(\cdot \mid x)\): observes only the problem \(x\), replicating inference-time conditions</li> <li> <strong>Teacher policy</strong> \(p_T(\cdot \mid x, y^*)\): receives privileged access to the ground-truth solution \(y^*\)</li> </ul> <p>Critically, both policies share identical parameters—they represent the same model under different conditioning contexts.</p> <h2 id="methodology">Methodology</h2> <p>The training procedure consists of three steps:</p> <p><strong>1. On-Policy Sampling from the Student.</strong> For a given problem \(x\), the student policy samples its own attempted solution:</p> \[\hat{y} = (\hat{y}_1,\ldots,\hat{y}_{|\hat{y}|}) \sim p_S(\cdot \mid x)\] <p><strong>2. Teacher-Student Distribution Computation.</strong> Both policies evaluate the student’s generated trajectory \(\hat{y}\). At each token position \(n\), they compute probability distributions over the next token \(y_n \in \mathcal{V}\) conditioned on the same student prefix \(\hat{y}_{&lt;n} = (\hat{y}_1,\ldots,\hat{y}_{n-1})\):</p> \[p_S(y_n \mid x, \hat{y}_{&lt;n}), \qquad p_T(y_n \mid x, y^*, \hat{y}_{&lt;n})\] <p>The teacher policy, informed by the correct solution \(y^*\), provides guidance toward reasoning trajectories that lead to the correct answer.</p> <p><strong>3. Per-Token Distribution Matching.</strong> We instantiate a <strong>full-vocabulary divergence objective</strong> that matches the teacher and student next-token distributions at each position. We define the trajectory-averaged, token-wise divergence:</p> <div class="equation-block"> $$ D(p_T \| p_S)(\hat{y} \mid x) = \frac{1}{|\hat{y}|} \sum_{n=1}^{|\hat{y}|} D\left(p_T(\cdot \mid x, y^*, \hat{y}_{&lt;n}) \,\|\, p_S(\cdot \mid x, \hat{y}_{&lt;n})\right) $$ </div> <p>where \(D\) can be any distribution divergence measure such as the generalized Jensen-Shannon divergence \(\text{JSD}_\beta\), defined for a weight \(\beta \in [0, 1]\) as:</p> \[\text{JSD}_\beta(p_T \| p_S) = \beta D_{\text{KL}}(p_T \| m) + (1 - \beta) D_{\text{KL}}(p_S \| m)\] <p>where \(m = \beta p_T + (1 - \beta) p_S\) is the interpolated mixture distribution. This full-vocabulary formulation provides dense, token-level feedback: the teacher, informed by \(y^*\), exposes the student to the entire distribution over plausible next tokens and guides it toward reasoning paths that lead to the correct answer.</p> <p>We minimize the expected divergence between teacher and student over on-policy student samples:</p> <div class="equation-block"> $$ \mathcal{L}(\theta) = \mathbb{E}_{(x,y^*)\sim \mathcal{S}} \left[ \mathbb{E}_{\hat{y}\sim p_S(\cdot|x)} \left[ D(p_T \| p_S)(\hat{y} \mid x) \right] \right] $$ </div> <p><strong>Gradients flow only through the student’s logits</strong>. The teacher serves as a fixed supervision target, despite both policies sharing the same underlying parameters but differing in their conditioning contexts.</p> <p>Importantly, we fix the teacher policy to be the initial policy, rather than the currently updating learning policy, as we find this helps stabilize training and implicitly acts as regularization to prevent excessive deviation from the initial policy.</p> <p><strong>Alternative Objective: Sampled-Token Distillation.</strong> As an alternative approach, we can use a policy-gradient formulation that operates only on sampled tokens. For each position \(n\), we define the advantage term:</p> \[A_n(x, \hat{y}) = \log p_T(\hat{y}_n \mid x, y^*, \hat{y}_{&lt;n}) - \log p_S(\hat{y}_n \mid x, \hat{y}_{&lt;n})\] <p>and optimize:</p> \[\mathcal{L}(\theta) = - \mathbb{E}_{(x,y^*) \sim \mathcal{S}} \left[ \mathbb{E}_{\hat{y} \sim p_S(\cdot \mid x)} \left[ \frac{1}{|\hat{y}|} \sum_{n=1}^{|\hat{y}|} A_n(x, \hat{y}) \log p_S(\hat{y}_n \mid x, \hat{y}_{&lt;n}) \right] \right]\] <p>where \(A_n(x,\hat{y})\) is treated as a constant (gradients do not flow through the advantage). Compared to the full-vocabulary divergence objective, this sampled-token approach uses the teacher’s log-probabilities to provide dense trajectory-level shaping signals without explicitly matching the full distribution at each step.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/opsd/prompt_exampel_opsd.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 3: Prompt construction for student and teacher policies. Both policies operate with identical parameters but receive different conditioning information. </div> <h2 id="experimental-results">Experimental Results</h2> <p>We evaluate OPSD on competition-level mathematical reasoning benchmarks (AIME 2024/2025, HMMT 2025, AMO-Bench) using the Qwen3 model family (1.7B, 4B, and 8B parameters).</p> <h3 id="performance-comparison">Performance Comparison</h3> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/opsd/main_result.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 4: Main results comparing OPSD against baseline methods across benchmarks. </div> <h3 id="computational-efficiency">Computational Efficiency</h3> <p>A particularly notable finding concerns computational efficiency. OPSD achieves superior performance while utilizing <strong>8× fewer tokens</strong> than GRPO:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/opsd/opsd_tokenefficiency.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 5: Token efficiency comparison between OPSD and GRPO. OPSD achieves higher performance with substantially reduced token consumption. </div> <p>This efficiency advantage stems from:</p> <ol> <li>Dense token-level supervision (versus sparse sequence-level rewards)</li> <li>Reduced generation budgets (2k tokens versus 16k for GRPO)</li> </ol> <p>In practice, this translates to <strong>reduced training time</strong> and <strong>lower computational requirements</strong>.</p> <h2 id="ablation-studies">Ablation Studies</h2> <h3 id="model-capacity-requirements">Model Capacity Requirements</h3> <p>Self-distillation requires sufficient model capacity to effectively rationalize solutions. We conducted experiments across three model scales:</p> <div class="highlight-box"> <strong>Key Finding:</strong> A minimum capacity threshold exists for effective self-distillation. </div> <ul> <li> <strong>1.7B parameters</strong>: OPSD yields marginal or negative effects</li> <li> <strong>4B parameters</strong>: Consistent improvements emerge</li> <li> <strong>8B parameters</strong>: Most substantial gains observed</li> </ul> <p>Below the capacity threshold, models lack the requisite reasoning ability to understand and rationalize why correct solutions work, even when provided access to them.</p> <h3 id="generation-length-analysis">Generation Length Analysis</h3> <p>Since the training objective operates at the token level, generation length directly impacts the quantity of supervision signal available:</p> <p>Increasing generation length from 1k → 2k → 4k tokens yields consistent performance improvements. This finding aligns with the intuitive understanding that more tokens provide additional opportunities for the teacher policy to guide the student’s reasoning process.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/opsd/gen_length_ablation.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 6: Pass@k performance curves showing the effect of generation length. Longer generation budgets provide increased teacher supervision. </div> <h3 id="objective-function-comparison">Objective Function Comparison</h3> <p>We compared two approaches for computing the divergence:</p> <ol> <li> <strong>Full-vocabulary divergence</strong>: Compute \(D(p_T \| p_S)\) over the entire vocabulary</li> <li> <strong>Sampled-token objective</strong>: Utilize only the sampled token in a policy-gradient formulation</li> </ol> <p>Results on Qwen3-4B:</p> <table> <thead> <tr> <th>Method</th> <th>AIME25</th> <th>HMMT25</th> </tr> </thead> <tbody> <tr> <td>Full-vocabulary</td> <td><strong>84.1%</strong></td> <td><strong>60.0%</strong></td> </tr> <tr> <td>Sampled-token</td> <td>82.1%</td> <td>57.3%</td> </tr> </tbody> </table> <p>The full-vocabulary approach provides richer supervision by exposing the student to the teacher’s complete distribution over plausible next tokens, though at increased memory cost.</p> <h2 id="limitations-and-future-directions">Limitations and Future Directions</h2> <p>While OPSD demonstrates strong empirical results up to 8B parameters, several research directions warrant investigation:</p> <p><strong>Scaling to larger models.</strong> The scaling behavior of self-distillation beyond 8B parameters remains an open question. Our hypothesis suggests larger models should exhibit greater benefits, but computational constraints precluded testing at frontier model scales.</p> <p><strong>Verification signal integration.</strong> The current framework does not explicitly incorporate correctness verification. Combining distribution matching with outcome-based verification signals could provide complementary learning objectives.</p> <p><strong>Curriculum learning strategies.</strong> When problems exceed the model’s comprehension threshold, even the teacher policy cannot provide meaningful supervision. Adaptive difficulty adjustment—gradually increasing problem complexity as the model improves—could enhance training effectiveness.</p> <h2 id="conclusion">Conclusion</h2> <p>On-Policy Self-Distillation demonstrates that sufficiently capable models can provide self-supervision by leveraging their ability to rationalize correct solutions. By conditioning a single model on different contexts—with and without privileged information—OPSD achieves:</p> <ul> <li>Superior performance compared to supervised fine-tuning</li> <li>Comparable or better results than reinforcement learning with <strong>8× improved token efficiency</strong> </li> </ul> <p>The central insight is conceptually elegant yet empirically powerful: evaluation and rationalization are computationally less demanding than generation from scratch. When provided access to correct answers, models can understand the underlying reasoning and effectively guide their weaker counterparts toward improved solutions.</p> <p>As models continue to scale, this self-teaching capability may become increasingly valuable—enabling more efficient training without the overhead of maintaining separate teacher models or the computational burden of extensive reinforcement learning.</p> <hr> <p><strong>Additional resources:</strong> The complete paper includes detailed ablations, implementation specifications, and analysis. All experiments employ the Qwen3 model family with LoRA fine-tuning on 8×A100 GPUs. Code and additional materials are available in the full publication.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2026 Siyan Zhao. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-9P289P4QZ7"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-9P289P4QZ7");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>